Jak wspomniano w rozdziale pierwszym, przebieg prac i etapy realizacji korespondują z kolejnymi spotkaniami projektowymi.
\begin{table}[!ht]
\begin{tabular}{|l|l|} \hline
Etap & Opis\\ \hline
1 & Projektowanie składni i systemu typów języka oraz architektury procesora. \\
  & Analiza istniejących procesorów opartych na FPGA\\  \hline
2 & Implementacja języka programowania i kompilatora \\
  & Zmiany w koncepcji dotyczącej procesora\\ \hline
3 & Implementacja modułu komunikacyjnego oraz procesora\\
  & Dalszy rozwój kompilatora \\ \hline
4 & Drobne poprawki w całym projekcie\\
  & Opracowanie przykładów działania, dokumentacja\\
\hline
\end{tabular}
\end{table}

\section{Etap pierwszy}
Pierwszy etap rozpoczął się po marcowym spotkaniu z prowadzącym. Wymagał on zagłębienia się w tematykę teorii kompilacji i budowy procesorów, w szczególności istniejących gotowych rozwiązań dla FPGA. Naszym celem było odpowiednie zaprojektowanie języka oraz dobór odpowiednich narzędzi do jego parsingu, transformacji i translacji do asemblera. Część sprzętowa wymagała wyboru i zaopatrzenia się w odpowiedni zestaw startowy oraz sprzęt do komunikacji komputer-FPGA. Należało też dokonać wyboru pomiędzy językami opisu sprzętu - Verilogiem a VHDLem. Istotną kwestią był taki sposób zaplanowania przedsięwzięcia by później - podczas implementacji procesora - nie okazało się, że zakupione zestawy startowe posiadają zbyt małą ilość bramek logicznych do realizacji założeń początkowych.
\subsection{Realizacja etapu}
Podjęliśmy decyzję o implementacji kompilatora w języku Haskell. Z wcześniejszych doświadczeń wiedzieliśmy, że język ten jest wyjątkowo dobrze przystosowany do trawersacji po strukturach i innych zadań powiązanych z kompilatorami. Do parsowania wybraliśmy bibliotekę parsec, do binaryzacji pakiet binary. Zdecydowaliśmy też o semantyce języka - stwiedziliśmy, że należy dać użytkownikowi możliwość użycia 2 typów zmiennych - liczb całkowitych i wektorów liczb. Wybraliśmy potrzebne elementy języka - pętle i instrukcje warunkowe. Zdecydowaliśmy o składni oraz formatowaniu i znakach białych. W kwestiach sprzętowych zdecydowaliśmy, że procesor zrealizujemy na zestawach startowych Terasic DE0-Nano które będą odbierały program kompilowany na platformach komputerowych Raspberry PI. Do komunikacji pomiędzy Raspberry PI a FPGA wybraliśmy układ UART. Zapoznaliśmy się z pracami na temat implementacji procesorów na FPGA oraz z ich konkretnymi przykładami.  
\section{Etap drugi}
Drugi etap rozpoczął się po spotkaniu w czerwcu na którym przedstawiliśmy skonkretyzowaną wizje projektu. Na spotkaniu zaproponowana została koncepcja procesora stosowego oraz podziału wektora o zmiennej długości na mniejsze. W ramach drugiego etapu planowaliśmy rozpocząć tworzenie kompilatora - rozpoczynając od parsera oraz prostego typecheckera. Mieliśmy również nadzieje rozpocząć prace nad pierwszą wersją tłumaczenia AST do asemblera. Planowaliśmy realizacje prototypowej komunikacji z użyciem UART.
\subsection{Realizacja etapu}
Udało nam się napisać parsera języka oraz zaprojektować dla niego odpowiednie AST. Zaimplementowaliśmy prosty moduł type-checkujący. Zaprojektowaliśmy pierwotną wersje asemblera z wykorzystaniem arbitralnej ilości rejestrów. Napisaliśmy moduł tłumaczący drzewo AST do ASM oraz zaimplementowaliśmy obsługę instrukcji warunkowych w ASM. Podjeliśmy też bardzo istotną decyzję dotyczącą kwestii sprzętowych - uznaliśmy, że kompilowanie programów na platformie Raspberry PI nie jest w realizacji projektu potrzebne. Zamiast tego zakupiliśmy konwertery USB-UART umożliwiające komunikacje wysyłanie i odbieranie danych z komputera poprzez wirtualny port COM. Dzięki temu udało się nam z projektu wyłączyć dodatkowy element jakim była obsługa Raspberry PI. Dokonaliśmy zmiany koncepcyjnej w architekturze assemblera i procesora - zdecydowaliśmy, że zamiast zwykłych rejestrów zaimplementujemy procesor stosowy co w znaczącym stopniu uprości kompilacje programów oraz zmniejszy ilość potrzebnych mnemoników. Zaimplementowaliśmy obsługę UART po stronie FPGA oraz PC. Przesłaliśmy pierwsze dane przez interfejs USB-UART. Udało nam się już w drugim etapie podjęcie prac nad procesorem w VHDL. Rozpoczęliśmy implementacje pierwszych stanów w maszynie stanowej FPGA oraz potrzebnych struktur - tablic pamięci oraz stosów. Rozpoczęliśmy analizę obsługi wektorów - podjęliśmy decyzję o przetwarzaniu ich w postaci 8 elementowych kawałków. Stworzyliśmy pierwszy - prototypowy - moduł dokonujący tłumaczenia asemblerowych mnemoników do postaci binarnego pliku - programu.
\section{Etap trzeci}
Trzeci etap rozpoczął się po październikowym spotkaniu dotyczącym działania procesora. Planowaliśmy w nim rozstrzygnąć pytania dotyczące procesora - kształ i działanie koprocesora arytmetycznego oraz działanie rejestrów wektorowych na które kopiowalibyśmy wektory przed rozpoczęciem obliczeń. Najważniejszym zadaniem była implementacja procesora dla urządzenia startowego. Chcieliśmy zbudować go inkrementalnie - tzn. dodawać kolejne stany maszyny tak by obsługiwały coraz bardziej złożone mnemoniki asemblera.
\subsection{Realizacja etapu}
Podjęliśmy decyzję o całkowitym zmodyfikowaniu modułu binaryzacji instrukcji asemblera. Jak nam poradzono przerobiliśmy instrukcje tak aby miały stałą długość natomiast stałe wykorzystane w programie doklejane były na koniec pliku binarnego. Zaimplementowaliśmy również nową - lepszą i bardziej odporną na błędy -  obsługę UART po stronie FPGA. Zaczęliśmy łączyć kolejne moduły VHDL w całość - pamięć na stałe liczbowe, pamięć intrukcji, stos wektorów. Zaimplementowalimy 2 stosy-rejestry na wektory. Następnie tak jak założyliśmy - inkrementalnie dodawaliśmy obsługę kolejnych komend - kopiowania wartości zmiennych do i z pamięci, kopiowanie danych ze stosu, itd. Zaimplementowaliśmy koprocesor arytmetyczny wykonujący wszystkie możliwe operacje na raz dla wektorów. Rozszerzyliśmy procesor o obsługę bardziej złożonych operacji - skoków JMP i mnemoników warunkowych (IF, IFZ). Dodaliśmy stany umożliwiające odsyłanie danych wyjściowych. Zmodyfikowaliśmy koncepcje dotyczące pętli LOOP. Od tej pory jest ona jedynym wyrażeniem nie zwracającym żadnej wartości. Zaimplementowaliśmy w języku C program obsługujący wysyłanie i odbieranie wyników programów z komputera wraz z obsługą błędów. Udało się nam przesłać przykładowe programy które zwracały poprawne wartości. Zaimplementowaliśmy przykładowe programy sprawdzające ogólne działanie programu, wykonujące dużą ilość iteracji. Zaimplementowaliśmy program liczący kolejne liczby fibonacciego w celu przedstawienia na kolejnym spotkaniu projektowym.
\section{Etap czwarty}
Czwarte spotkanie projektowe dotyczyło konkretnych przykładów obliczeń jakie mielibyśmy zaprezentować na procesorze. W danym etapie planowaliśmy rozszerzenie ilości obługiwanych operacji o 3 kolejne. Chcieliśmy również poprawić pewne błędy języka i ułatwić proces kompilacji oraz wysyłania programu. 
\subsection{Realizacja etapu}
Dodaliśmy do języka 3 nowe elementy drzewa syntaktycznego - operację rot90, scalarProd oraz modulo. Rozszerzyliśmy również asembler o wektorowe wsparcie dla tych operacji. Przy dobieraniu funkcji kierowaliśmy się tym jakie rzeczywiste operacje mógłby chcież wykonać użytkownik. I tak - rot90 - rotacja została dodana w celu pokazania łatwości rozszerzalności procesora o kolejne najróżniejsze komendy. Operacja scalarProd jest iloczynem skalarnym i dodanie jej umotywowaliśmy faktem, że w rzeczywistych obliczenia jest bardzo często używana. Również operacje modulo dodaliśmy mając na uwadze jak istotnym jest ona elementem obliczeń. Na końcu zaimplementowaliśmy w rozwijanym przez nas języku przykładowe programy pokazujące poprawność działania ale i przydatnośc wymienionych operacji.