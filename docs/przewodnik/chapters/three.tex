\section{Użyte technologie}

Kompilator został zaimplementowany w języku Haskell[1][2]. Jest to funkcyjny, silnie typowany język wysokiego poziomu z niezwykle ekspresyjnym systemem typów, szczególnie dobrze nadający się do pisania kompilatorów, choć z powodzeniem stosowany również jako język ogólnego przeznaczenia. Drugim naturalnym kandydatem na język implementacji kompilatora jest język ML, jednak Haskell posiada większą społeczność, bardziej rozbudowany zestaw bibliotek i świetny, optymalizujący kompilator GHC. Dwoma wadami Haskella są: brak dobrego środowiska pracy (takiego na przykład, jak IntelliJ do języka Java) oraz stosunkowo stroma krzywa uczenia. Nie było to jednak w żadnej mierze problemem, jako że język był przez nas wcześniej używany w pracy zawodowej, więc nie było konieczności zapoznawania się z nowym językiem czy paradygmatem programowania. Do budowania projektu używaliśmy zamiennie dwóch dostępnych dla Haskella systemów budowania: Cabal oraz Stack. Ten pierwszy jest dobrze znany i sprawdzony, choć cieszy się opinią nieprzyjemnego w używaniu (ukuto nawet termin \textit{cabal hell} w odniesieniu do zamieszania z wersjami pakietów, jakie Cabal potrafi wytworzyć). Stack jest nowym (tegorocznym) narzędziem, które stara się rozwiązać wiele wad Cabala, ale wciąż nie jest tak stabilny, jakbyśmy sobie tego mogli życzyć.

Do bsługi komunikacji po stronie komputera wykorzystano język C. Powodem była konieczność niskopoziomowej obsługi portu szeregowego, co w języku C daje się zrobić zupełnie naturalnie, bez konieczności wykorzystania bibliotek innych niż standardowa. W początkowej wersji projektu komunikacja przebiegała nie bezpośrednio między komputerem PC, a koprocesorem, a pomiędzy umieszczonym w środku Raspberry Pi. Zrezygnowano jednak z takiego rozwiązania, gdy okazało się, że piny GPIO na Raspberry Pi nie radzą sobie z transmisją szeregową i przekłamują bity. Zamiast tego użyto przejściówki UART-USB, pozwalającej podłączać koprocesor bezpośrednio do portu USB na komputerze i obsługiwać go tak, jak każde inne urządzenie wejścia-wyjścia w Linuksie. Jako bazę do implementacji interfejsu UART na FPGA wybrano projekt [3], który był napisany bardzo starannie i działał niezawodnie, jak również był udostępniony na dogodnej licencji.

Przy projektowaniu i implementacji układów na FPGA mamy dwie możliwości jeśli chodzi o język i dwie, jeśli chodzi o dostawcę sprzętu. Wybraliśmy język VHDL zamiast jednej z wersji języka Verilog, jako że jest nowocześniejszy i dostępnych jest więcej materiałów edukacyjnych. Jako dostawcę sprzętu wybraliśmy firmę Altera, która zdaje się mieć obecnie nieco więcej dynamiki, niż jej jedyny poważny konkurent -- Xilinx. Zastosowaliśmy niewielką, edukacyjną płytkę Altera De0-nano[5], ale ze względu na kompaktowy projekt procesora cała logika zmieściła się na niej bez najmniejszego problemu. Do projektowania i syntezy układów używaliśmy środowiska Quartus II firmy Altera[4], które dostarcza, oprócz środowiska programistycznego i kompilatora (niezwykle zaawansowanego -- kompilatory/syntezatory FPGA nie tylko wykonują pracę zwykłego kompilatora, ale także syntezują fizyczny kształt układu i układają go na płytce, oraz wykonują analizy działania układu), szereg narzędzi ułatwiających pracę z FPGA, jak na przykład symulatory działania układu czy asystenci projektowania.

Z technologii okołoprogramistycznych użytych w projekcie warto wymienić system kontroli wersji Git, oraz witrynę GitHub.com, które pozwoliły nam sprawnie współpracować i śledzić postęp prac w całym projekcie.

\section{Podjęte decyzje projektowe}
Koncepcja systemu ewoluowała w raz ze zwiększaniem się naszego doświadczenia w tworzeniu takich systemów. Początkowo procesor miał być podobny do zwykłych procesorów PC, posiadać rejestry i architekturę Von Neumanna. Ostatecznie jednak, po przeczytaniu licznych źródeł, zadecydowaliśmy o zrealizowania procesora jako rodzaj hybrydowej maszyny stosowej (stack machine). Zamiast rejestrów używane są trzy stosy (dwa dodatkowe stosy potrzebne są do specyficznego przetwarzania długich wektorów, szczegółowy opis tego pomysłu można znaleźć w dokumentacji technicznej), instrukcje są trzymane w dedykowanej pamięci instrukcji, zmienne trzymane są w pamięci ram, a stałe w dedykowanej pamięci stałych. Dzięki temu procesor nie posiada rejestrów, ale nie ma też wszystkich cech maszyny stosowej -- jest połączeniem kilku podejść do konstrukcji procesorów. Taki sposób wydawał się być najlepiej dostosowany do sposobu, w jaki w naszym systemie traktowane są wektory.

Taka decyzja rzutowała na techniczne szczegóły języka, w szczególności zupełnie zmieniła postać assemblera, który od tej pory obsługiwał instrukcje stosowe. Kolejną ważną decyzją było przyjęcie stałej długości instrukcji. Dzięki prefiksowemu kodowaniu udało się zmieścić wszystkie instrukcje (wraz z operandami) na jednym bajcie, co niezwykle ułatwia ich przesyłanie i obsługę w koprocesorze. Było to możliwe również dzięki przyjęciu sposobu przechowywania stałych w programie: zamiast używać stałych (które wszak są wektorami, jak wszystko w naszym języku) bezpośrednio jako operandów do instrukcji, zapisujemy je w specjalnej tablicy stałych, którą wypełniamy przed uruchomieniem programu, a instrukcje posiadają tylko adres w tablicy stałych.
